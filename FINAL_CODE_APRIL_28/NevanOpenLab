#include "Enes100.h"
#include "HX711.h"

//pinouts update as needed
const int FL_IN1 = 12, FL_IN2 = 13, FL_EN = 11; //FL - front left
const int FR_IN1 = 2, FR_IN2 = 4, FR_EN = 3; //FR - front right
const int BL_IN1 = 8, BL_IN2 = 5, BL_EN = 10;  //BL - back left
const int BR_IN1 = 7, BR_IN2 = 6, BR_EN = 9; //BR - back right
const int piezoPin = A5; // Piezo Pin allocation

//5 sucks

//scale setup
const int LOADCELL_DOUT_PIN = 17;
const int LOADCELL_SCK_PIN = 18;
HX711 scale;

// PD tuning constants
const float kP_position = 2;
const float kD_position = 0.1;
const float kP_theta = 0;
const float kD_theta = 0;
int z = 0;

const float positionTolerance = 0.05;
const float thetaTolerance = 0.02;
const unsigned long updateInterval = 20; // micros

//power should be given in range [-1, 1] which corresponds to max speed and minimum speed, 0 is stop
//Power Values that stop each motor
/*FR: 0.13
FL: 0.15
BL: 0.13
BR: 0.2*/
void setMotorPower(int motor, float power) { //Input motor name either FL, FR, BL, BR and power calculated from set driver power

  if (motor == 0) { //FL
    // Front Left motor
    float pow = constrain(fabs(power), 0.15, 0.8);
    power = constrain(power, -1.0, 1.0);
    int pwm = (int)(fabs(pow) * 255);  // Scale to PWM range
    if (power > 0) {
      digitalWrite(BL_IN1, HIGH);
      digitalWrite(BL_IN2, LOW);
    } else if (power < 0) {
      digitalWrite(BL_IN1, LOW);
      digitalWrite(BL_IN2, HIGH);
    } else {
      digitalWrite(BL_IN1, LOW);
      digitalWrite(BL_IN2, HIGH);
      pwm = 1;
    }
    analogWrite(BL_EN, pwm);

  } else if (motor == 1) { //FR
    // Front Right motor
    float pow = constrain(fabs(power), 0.13, 1.0);
    power = constrain(power, -1.0, 1.0);
    int pwm = (int)(fabs(pow) * 255);  // Scale to PWM range
    if (power > 0) {
      digitalWrite(FR_IN1, HIGH);
      digitalWrite(FR_IN2, LOW);
    } else if (power < 0) {
      digitalWrite(FR_IN1, LOW);
      digitalWrite(FR_IN2, HIGH);
    } else {
      digitalWrite(FR_IN1, LOW);
      digitalWrite(FR_IN2, LOW);
    }
    analogWrite(FR_EN, pwm);

  } else if (motor == 2) { //BL
    // Back Left motor
    float pow = constrain(fabs(power), 0.13, 0.8);
    power = constrain(power, -1.0, 1.0);
    int pwm = (int)(fabs(pow) * 255);  // Scale to PWM range
    if (power > 0) {
      digitalWrite(FL_IN1, HIGH);
      digitalWrite(FL_IN2, LOW);
    } else if (power < 0) {
      digitalWrite(FL_IN1, LOW);
      digitalWrite(FL_IN2, HIGH);
    } else {
      digitalWrite(FL_IN1, LOW);
      digitalWrite(FL_IN2, HIGH);
      pwm = 1;
    }
    analogWrite(FL_EN, pwm);

  } else if (motor == 3) { //BR
    // Back Right motor
    float pow = constrain(fabs(power), 0.2, 1.0);
    power = constrain(power, -1.0, 1.0);
    int pwm = (int)(fabs(pow) * 255);  // Scale to PWM range
    if (power > 0) {
      digitalWrite(BR_IN1, HIGH);
      digitalWrite(BR_IN2, LOW);
    } else if (power < 0) {
      digitalWrite(BR_IN1, LOW);
      digitalWrite(BR_IN2, HIGH);
    } else {
      digitalWrite(BR_IN1, LOW);
      digitalWrite(BR_IN2, LOW);
    }
    analogWrite(BR_EN, pwm);
  }
}

void setDrivePower(float vx, float vy, float omega) { //given velotiy for x y and theta set drive power of each motor
  float frontLeft  = vx + vy + omega; //update after looking at wheel config
  float frontRight = vx - vy - omega;
  float backLeft   = vx - vy + omega;
  float backRight  = vx + vy - omega;

  // Normalize speeds but keep them proportional
  float maxMagnitude = max( 1.0, max(fabs(frontLeft), max(fabs(frontRight), max(fabs(backLeft), fabs(backRight)))));

  Serial.println(frontLeft);
  Serial.println(frontRight);
  Serial.println(backLeft);
  Serial.println(backRight);
  


  // Normalize to keep values within [-1, 1]
  frontLeft  /= maxMagnitude;
  frontRight /= maxMagnitude;
  backLeft   /= maxMagnitude;
  backRight  /= maxMagnitude;

  Serial.println(frontLeft);
  Serial.println(frontRight);
  Serial.println(backLeft);
  Serial.println(backRight);
  

  // Send powers to motors (replace with your motor commands)
  setMotorPower(0, frontLeft);
  setMotorPower(1, frontRight);
  setMotorPower(2, backLeft);
  setMotorPower(3, backRight);
}


float normalizeAngle(float angle) { //use normalize angle to get optimal pathing
  while (angle > PI) angle -= 2 * PI;
  while (angle < -PI) angle += 2 * PI;
  return angle;
}

void driveTo(float xTarget, float yTarget, float thetaTarget) { //drives to give x y and theta target using PD controllers and tolerances above
  float prevErrorX = 0;
  float prevErrorY = 0;
  float prevErrorTheta = 0;

  long startTime = micros();
  while (true) {
    /*if (now - lastUpdate < updateInterval) {
      continue; // Don't update yet, but keep looping
    }*/
    long currentTime = micros();
    long dt = currentTime - startTime; // convert to seconds
    startTime = currentTime;

    // Get current position
    float x = Enes100.getX();
    float y = Enes100.getY();
    float theta = Enes100.getTheta(); // in radians

    // Calculate errors
    float errorX = xTarget - x;
    float errorY = yTarget - y;
    float errorTheta = normalizeAngle(thetaTarget - theta);

    // Check if we're within tolerance
    if (fabs(errorX) < positionTolerance &&
        fabs(errorY) < positionTolerance){
        //fabs(errorTheta) < thetaTolerance
      setDrivePower(0, 0, 0);
      break;
    }

    // Derivatives
    float dErrorX = (errorX - prevErrorX) / (((float)dt) / 1000000);
    float dErrorY = (errorY - prevErrorY) /  (((float)dt) / 1000000);
    float dErrorTheta = (normalizeAngle(errorTheta - prevErrorTheta)) /  (((float)dt) / 1000000);

    // PD control in field space
    float vxField = kP_position * errorX + kD_position * dErrorX;
    float vyField = kP_position * errorY + kD_position * dErrorY;

    // Convert to robot frame
    float cosTheta = cos(-theta);
    float sinTheta = sin(-theta);
    float vxRobot = vxField * cosTheta - vyField * sinTheta;
    float vyRobot = -(vxField * sinTheta + vyField * cosTheta);


    // Angular velocity
    float omega = kP_theta * errorTheta + kD_theta * dErrorTheta;

    // Clamp outputs
    vxRobot = constrain(vxRobot, -1.0, 1.0);
    vyRobot = constrain(vyRobot, -1.0, 1.0);
    omega = constrain(omega, -1.0, 1.0);
    if(z == 100){
    Enes100.print("vx: ");
    Enes100.println(vxRobot);
    Enes100.print("vy: ");
    Enes100.println(vyRobot);
    Enes100.print("omega: ");

    Enes100.println(omega);
    z = 0;
    }
    else{
      z++;
    }


    //save values for next loop
    prevErrorX = errorX;
    prevErrorY = errorY;
    prevErrorTheta = errorTheta;
    // Send power to drive system
    setDrivePower(vxRobot, vyRobot, omega);
  }
}

void chooseMaterial(float reading){
  if(reading>220){
    Enes100.mission(WEIGHT, HEAVY);
    Serial.println("heavy");
  }
  else if(reading>140){
    Enes100.mission(WEIGHT, MEDIUM);
        Serial.println("medium");

  }
  else{
    Enes100.mission(WEIGHT, LIGHT);
    Serial.println("light");

  }
}

// Piezo code
// piezo const

void piezo () {
const int plasticThreshold = 850; // Higher value for plastic due to stronger vibrations 850 is placeholder
const int foamThreshold = 650; // Lower value for foam due to weaker vibrations, 650 is placeholder
// run material identification using piezo
  int piezoValue = analogRead(piezoPin); // Piezo reads values from 512-1023
  //Compares piezo reading to each threshold to determine material
  if (piezoValue > plasticThreshold) {
    Serial.println("PLASTIC");
  } 
  else if (piezoValue > foamThreshold) {
    Serial.println("FOAM");
  }
  else {
    Serial.println("NOTHING");
  }
}



// Controls angular movement
int pd_angular_controller(float setpoint, float pv, float previous_error, long diffTime){
    float kp = 70;
    float kd = 50;
    float error = normalizeAngle(setpoint - pv);
    float derivative = 0;
    if (diffTime > 0) derivative = ((normalizeAngle(error - previous_error)) / (((float)diffTime) / 1000000));
    float control = kp * error + kd * derivative;
    control = constrain(control, -255, 255);
    return (int)control;
}

//rotate function with CW and CCW movement
void rotateOTV (int p) {
  float power = constrain(p / 255.0f, -1.0, 1.0);  // Scale to range -1.0 to 1.0
  if (p < 0) {
    motorCW(abs(power));  // CW uses positive speed
  } else {
    motorCCW(abs(power)); // CCW uses positive speed
  }
}

void motorCW(float p){
  setMotorPower(0, p);  // FL
  setMotorPower(2, p);  // BL
  setMotorPower(1, -p); // FR
  setMotorPower(3, -p); // BR
}

void motorCCW(float p){
  setMotorPower(0, -p);  // FL
  setMotorPower(2, -p);  // BL
  setMotorPower(1, p);   // FR
  setMotorPower(3, p);   // BR
}

// Rotate OTV FUNCTION CODE

// void rotateOTV (int p) {
//   if (p < 0) {
//     p = abs(p);
//     motorCW(FRD1, FRD2, p);
//     motorCW(FLD1, FLD2, p);
//     motorCW(BRD1, BRD2, p);
//     motorCW(BLD1, BLD2, p);
//   } else {
//     p = abs(p);
//     motorCCW(FRD1, FRD2, p);
//     motorCCW(FLD1, FLD2, p);
//     motorCCW(BRD1, BRD2, p);
//     motorCCW(BLD1, BLD2, p);
//   }

// }


// Angle correction to a set angle
void correctOrientation(float tf) {
  tf = normalizeAngle(tf);
  float ti = Enes100.getTheta();
  float dt = normalizeAngle(tf - ti);
  long startTime = micros();
  long diffTime = 0;
  float P = 0;
  while (fabs(normalizeAngle(tf-ti)) > 0.02) {
    diffTime = micros() - startTime;
    startTime = micros();
    ti = Enes100.getTheta();
    P = pd_angular_controller(tf, ti, dt, diffTime);
    dt = normalizeAngle(tf - ti);
   // Enes100.println(dt);
    //Enes100.println(P);
    rotateOTV(P);
  }
  Enes100.println("I'm done rotating!!!!!! :DDDDDDDDDDDDDDD");
  setDrivePower(0,0,0); //stopotv();
}

void setup() {
 Enes100.begin("Work in Progress", MATERIAL, 77, 1120, 15, 16);
  delay(200);
  Enes100.println("Successfully connected to the Vision System"); 
  //pinMode(FL_IN1, OUTPUT); pinMode(FL_IN2, OUTPUT); pinMode(FL_EN, OUTPUT);
  pinMode(11, OUTPUT); pinMode(13, OUTPUT); pinMode(12, OUTPUT);
  pinMode(10, OUTPUT); pinMode(9, OUTPUT); pinMode(8, OUTPUT);
    pinMode(2, OUTPUT); pinMode(3, OUTPUT); pinMode(4, OUTPUT);
        pinMode(1, OUTPUT); pinMode(6, OUTPUT); pinMode(7, OUTPUT);


  //pinMode(BL_IN1, OUTPUT); pinMode(BL_IN2, OUTPUT); pinMode(BL_EN, OUTPUT);
  //pinMode(BR_IN1, OUTPUT); pinMode(BR_IN2, OUTPUT); pinMode(BR_EN, OUTPUT);
  //Serial.begin(9600);
  Serial.println("succesful begin");
  
  // SCALE setup
  scale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN);
  scale.set_scale(-770.36);
  scale.tare();   
}


// Total Navigation 
void mission() {
// declaring Getting current position in mission function.
    float x = Enes100.getX();
    float y = Enes100.getY();
    float theta = Enes100.getTheta(); // in radians
//Start orientation and movement towards payload
if (y < 1) {
    correctOrientation(1.55); // might need to correct angle based on vision system numbers
    delay(100);
    driveTo(0.35, 0.44, 1.55); // sets starting position
    delay(100);
    driveTo(0.35, 1.34, 1.55); // stops in front of payload
    delay(100);
    driveTo(0.35, 1.85, 1.55);// alligning payload to intake
    delay(100);
    setDrivePower(1,0,0);//moving at full speed into payload
    delay(1500); //moves at top speed for 1.5 seconds into the wall
   setDrivePower(0,0,0); // stop otv
  } 
  else {
     correctOrientation(-1.55); // might need to correct angle
     delay(100);
     driveTo(0.35, 1.59, -1.55); // sets starting position
     delay(100);
     driveTo(0.35,0.68,-1.55);// stops in front of payload
     delay(100);
     driveTo(0.35, 0.13,-1.55);// alligning payload to intake
     delay(100);
     setDrivePower(1,0,0);//moving at full speed into payload
    delay(1500); //moves at top speed for 1.5 seconds into the wall
     setDrivePower(0,0,0); // stop otv
  }

delay (1000); // delaying by a 1 second before fufilling mission objectives 

// Fulfill mission objectives 

// Testing weight 

// Code to define weight
chooseMaterial(scale.get_units(10));
Enes100.println(scale.get_units(10));
  
delay(100); // Short delay to ensure multiple readings

// run material identification using piezo

piezo();

delay(100); // Short delay to ensure multiple readings

//Code to drive otv back to the limbo after mission indentification

if (y < 1) {
    driveTo(0.35,0.68,-1.55);// moving away from wall to allow correct orientation
    delay(100);
    correctOrientation(1.55); // turning the front of the OTV 
    driveTo(0.35, 2, 1.55); // to return the otv to the other edge of the arena
    delay(100); //short delay before it begins strafing 
    driveTo(2.8,2,1.55); //navigate forward before strafing into limbo
}
else {
  driveTo(0.35, 2, 1.55); // ensure it is at the very edge of the 
  delay(100);
  //no need to correct orientation already at the edge of arena
    driveTo(2.8,2,1.55); //strafe forward before going into limbo
}
// Aligning to the front of the limbo

 // moving under Limbo
 delay(100); // short delay before shifting to the front of the OTV
driveTo(2.8,1.63,1.55); // fropm edge to the front of the middle of the limbo
delay(100); // short delay before getting to goal zone
driveTo(3.96,1.63,1.55); // to the goal zone. 

}


void loop() {
    if(Enes100.isVisible()){
    correctOrientation(1.55); // might need to correct angle based on vision system numbers
    delay(100);
    driveTo(0.35, 0.44, 0); // sets starting position
    delay(100000000000);
    }
    //delay(100000000000);
}




  

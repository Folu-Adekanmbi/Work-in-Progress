#include "Enes100.h"

// Orients otv to specified angle
void correctOrientation(float tf){
  float ti = Enes100.getTheta();
  float dt = ((tf - (ti + 2*PI)) % (2*PI));

  if (dt != 0 && dt <= PI) {  // Rotate clockwise
    rotateCW();
    while  (((tf - (ti + 2*PI)) % (2*PI)) > 0.1) {
      ti = Enes100.getTheta();
      delay(1)
    }
  } 
  else {  // Rotate counter clockwise
    rotateCCW();
    while  (((tf - (ti + 2*PI)) % (2*PI)) > 0.1) {
      ti = Enes100.getTheta();
      delay(1)
    }
  }
   stopotv()  // Stop when angle is reached
}

// Moves to specific coordinate position
void  moveHere(float xf, float yf) {
  float ti = Enes100.getTheta();
  float xi = Enes100.getX();
  float yi = Enes100.getY();

  int quadAngle = ((ti + 2*PI + PI/4) / (PI/2)) * (PI/2)) % 2*PI; // Gets closest 90 degree multiple
  correctOrientation(quadAngle);

  while (abs(xf - xi) > 0.01 || abs(yf - yi) > 0.01) {  // Continues looping until ideal coordinates are reached
    xi = Enes100.getX();
    yi = Enes100.getY();
    switch (angle) {
      case 0:  // Facing upwards
        if (yi < yf) {
          driveForwards();
        }
        else if (yi > yf) { 
          driveBackwards();
        }
        if (xi < xf) {
          strafeRight();
        }
        else if (xi > xf) {
          strafeLeft();
        }
        break;

      case PI/4:  // Facing right
        if (xi < xf) {
          driveForwards();
        }
        else if (xi > xf) {
          driveBackwards();  
        }
        if (yi < yf) {
          strafeLeft(); 
        }
        else if (yi > yf) {
          strafeRight();  
        }
        break;

      case PI/2:  // Facing downwards
        if (yi > yf) {
          driveForwards(); 
        }
        else if (yi < yf) {
          driveBackwards();  
        }
        if (xi > xf) {
          strafeRight();  
        }
        else if (xi < xf) {
          strafeLeft();  
        }
        break;

      case 3*PI/4:  // Facing left
        if (xi > xf) {
          driveForwards(); 
        }
        else if (xi < xf) {
          driveBackwards(); 
        }
        if (yi > yf) {
          strafeLeft();  
        }
        else if (yi < yf) {
          strafeRight(); 
        }
        break;
    }
    
    xi = Enes100.getX(); 
    yi = Enes100.getY(); 

    delay(1);  // Small delay to allow motors to react
  }
  stopotv();
}

void setup() {
    // Initialize Enes100 Library
    // Team Name, Mission Type, Marker ID, Room Number, Wifi Module TX Pin, Wifi Module RX Pin
    Enes100.begin("Work in Progress", MATERIAL, 77, 1116, 3, 2);
    // At this point we know we are connected.
    Enes100.println("Connected...");
}

void loop() {
    float x, y, t; bool v; // Declare variables to hold the data
    //Enes100.getX will make sure you get the latest data available to you about your OTV's location.
    //The first time getX is called, X, Y, theta and visibility are queried and cached.
    //Subsequent calls return from the cache, so there is no performance gain to saving the function response to a variable.

    x = Enes100.getX();  // Your X coordinate! 0-4, in meters, -1 if no aruco is not visibility (but you should use Enes100.isVisible to check that instead)
    y = Enes100.getY();  // Your Y coordinate! 0-2, in meters, also -1 if your aruco is not visible.
    t = Enes100.getTheta();  //Your theta! -pi to +pi, in radians, -1 if your aruco is not visible.
    v = Enes100.isVisible(); // Is your aruco visible? True or False.

    if (v) // If the ArUco marker is visible
    {
        Enes100.print(x); // print out the location
        Enes100.print(",");
        Enes100.print(y);
        Enes100.print(",");
        Enes100.println(t);
    }
}
  
  

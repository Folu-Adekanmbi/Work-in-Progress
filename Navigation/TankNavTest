#include "cmath"
#include "iostream"
#include "Arduino.h"
#include "Tank.h"
#include "Enes100.h"

void driveForwards() {
  Tank.setRightMotorPWM(100);
  Tank.setLeftMotorPWM(100);
}
void driveBackwards() {
  Tank.setRightMotorPWM(-100);
  Tank.setLeftMotorPWM(-100);
}
void motorCW() {
  Tank.setRightMotorPWM(-100);
  Tank.setLeftMotorPWM(100);
}
void motorCCW() {
  Tank.setRightMotorPWM(100);
  Tank.setLeftMotorPWM(-100);
}

// Orients otv to specified angle
void correctOrientation(float tf){
  float ti = Enes100.getTheta();
  float dt = tf - ti;
  Enes100.print(dt);

  if (dt == 0) {
    Tank.turnOffMotors();
  }
  
  if (dt >= -PI && dt < 0 || dt < 2*PI && dt > PI) {  // Rotate clockwise
    motorCW();
    while  (abs(tf - ti) > 0.1) {
      ti = Enes100.getTheta();
      delay(10);
    }
  } 
  else if (dt <= PI && dt > 0 || dt > -2*PI && dt < -PI) {  // Rotate counter clockwise
    Enes100.println("I am running! 2");
    motorCCW();
    while  (abs(tf - ti) > 0.1) {
      ti = Enes100.getTheta();
      delay(10);
    }
  }
  Tank.turnOffMotors();  // Stop when angle is reached
}

void  moveHere(float xf, float yf) {
  float ti = Enes100.getTheta();
  float xi = Enes100.getX();
  float yi = Enes100.getY();
  
  float quadAngle = round((2*ti)/PI) * (PI/2);
  Enes100.println(quadAngle);
  correctOrientation(quadAngle);
  int degreeAngle = (int) (quadAngle * (180/PI) + 180);

  while (abs(xf - xi) > 0.01 || abs(yf - yi) > 0.01) {  // Continues looping until ideal coordinates are reached
    xi = Enes100.getX();
    yi = Enes100.getY();
    switch (degreeAngle) {
      case 0:  // Facing upwards
        if (yi < yf) {
          driveForwards();
        }
        else if (yi > yf) { 
          driveBackwards();
        }
        break;

      case 90:  // Facing right
        if (xi < xf) {
          driveForwards();
        }
        else if (xi > xf) {
          driveBackwards();  
        }
        break;

      case 180:  // Facing downwards
        if (yi > yf) {
          driveForwards(); 
        }
        else if (yi < yf) {
          driveBackwards();  
        }
        break;

      case 270:  // Facing left
        if (xi > xf) {
          driveForwards(); 
        }
        else if (xi < xf) {
          driveBackwards(); 
        }
        break;
    }
    
    xi = Enes100.getX(); 
    yi = Enes100.getY(); 

    delay(100);  // Small delay to allow motors to react
  }
  Enes100.println("I am not running! :( 2");
  Tank.turnOffMotors();
}


void setup() {
  Tank.begin();
  Enes100.begin("Work in Progress", MATERIAL, 15, 1116, 52, 50);
  delay(200);
  Enes100.println("Successfully connected to the Vision System");
}

void loop() {
  float x, y, t; bool v; // Declare variables to hold the data
  x = Enes100.getX();  // Your X coordinate! 0-4, in meters, -1 if no aruco is not visibility (but you should use Enes100.isVisible to check that instead)
  y = Enes100.getY();  // Your Y coordinate! 0-2, in meters, also -1 if your aruco is not visible.
  t = Enes100.getTheta();  //Your theta! -pi to +pi, in radians, -1 if your aruco is not visible.
  v = Enes100.isVisible(); // Is your aruco visible? True or False.
    if (v) {
      if (Enes100.getY() > 1) {
          correctOrientation(-PI/2);
      }
      else {
          correctOrientation(PI/2);
      }
  }

}

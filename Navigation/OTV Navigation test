#include <Enes100.h>

//F is front, B is back, R is right, L is left, D is drive, S is speed for these pin assignments
#define FRD1 8
#define FRD2 7
#define FLD1 10
#define FLD2 11
#define BRD1 6
#define BRD2 5
#define BLD1 12
#define BLD2 13
#define S 9

// Normalize angle to [-π, π]
float normalizeAngle(float angle) {
  angle = fmod(angle, 2*PI);
  if (angle > PI) angle -= 2 * PI;
  if (angle < -PI) angle += 2 * PI;
  return angle;
}

// Controls angular movement
int pd_controller(float setpoint, float pv, float previous_error, long diffTime){
    float kp = 1;
    float kd = 1;
    float error = setpoint - pv;
    float derivative = 0;
    if (diffTime > 0) derivative = ((error - previous_error) / (((float)diffTime) / 1000000));
    float control = kp * error + kd * derivative;
    control = constrain(control, -255, 255);
    return (int)control;
}

// Controls linear movement
int pd_linear_controller(float target_distance, float current_distance, float previous_error, long diffTime) {
    float kp = 1;
    float kd = 1;
    float error = fabs(target_distance - current_distance);
    float derivative = (error - previous_error) / ((float)diffTime);
    float control = kp * error + kd * derivative;
    return control;
}

// Angle correction to a set angle
void correctOrientation(float tf) {
  tf = normalizeAngle(tf);
  float ti = Enes100.getTheta();
  float dt = tf - ti;
  long startTime = micros();
  long diffTime = 0;
  float P = 0;
  while (abs(tf-ti) > 0.05) {
    diffTime = micros() - startTime;
    ti = Enes100.getTheta();
    P = pd_controller(tf, ti, dt, diffTime);
    dt = (tf - ti);
    startTime = micros();
    Enes100.println(dt);
    Enes100.println(P);
    rotateOTV(P);
  }
  stopotv();
}

float quadAngle(float t) {
  if (t >= PI / 4 && t < 3 * PI / 4) {    
    t = PI / 2;
  }
  else if (t >= 3 * PI / 4 && t < 5 * PI / 4) {                         
    t = PI;
  }
  else if (t >= t * PI / 4 && t < 7 * PI / 4) {               
    t = 3 * PI / 2;
  }
  else {
    t = 0;
  }
  return t
}

// Moves to specific coordinates
void moveHere(float xf, float yf) {
  float xi = Enes100.getX();
  float yi = Enes100.getY();
  float ti = normalizeAngle(Enes100.getTheta());
  float dy = fabs(yf - yi);
  float dx = fabs(xf - xi);
  long startTime = micros();
  long diffTime = 0;
  float P = 255;

  qA = quadAngle(ti);
  correctOrientation();

  float tolerance = 0.1;  // Increased tolerance for linear movement

  // Moves robot in right direction based on cardinal direction
  if (qA == 3 * PI / 2) { // Robot facing up
    if (dy != 0) { // Checks if needed to move along y 
      while (dy > tolerance) {
        diffTime = micros() - startTime;
        yi = Enes100.getY();
        P = pd_linear_controller(yf, yi, dy, diffTime);
        startTime = micros();
        dy = fabs(yf - yi);
        if (yf > yi) { // Move up
          driveForwards(P);
        }
        else { // Move down
          driveBackwards(P);
        }
      }
    }
    if (dx != 0) { // Checks if needed to move along x 
      while (dx > tolerance) {
        diffTime = micros() - startTime;
        xi = Enes100.getX();
        P = pd_linear_controller(xf, xi, dx, diffTime);
        startTime = micros();
        dx = fabs(xf - xi);
        if (xf > xi) { // Move right
          strafeRight(P);
        }
        else { // Move left
          strafeLeft(P);
        }
      }
    }
  }
  else if (qA == PI) { // Robot facing right
    if (yf != yi) { // Checks if needed to move along y
      if (yf > yi) { // Move up
        strafeLeft(255);
        while (fabs(yf - yi) > tolerance) {
          yi = Enes100.getY();
        }
      }
      else { // Move down
        strafeRight(255);
        while (fabs(yf - yi) > tolerance) {
          yi = Enes100.getY();
        }
      }
    }
    if (xf != xi) { // Checks if needed to move along x 
      if (xf > xi) { // Move right
        driveForwards(255);
        while (fabs(xf - xi) > tolerance) {
          xi = Enes100.getX();
        }
      }
      else { // Move left
        driveBackwards(255);
        while(fabs(xf - xi) > tolerance) {
          xi = Enes100.getX();
        }
      }
    }
  }
  else if (qA == PI / 2) { // Robot facing down
    if (yf != yi) { // Checks if needed to move along y
      if (yf > yi) { // Move up
        driveBackwards(255);
        while (fabs(yf - yi) > tolerance) {
          yi = Enes100.getY();
        }
      }
      else { // Move down
        driveForwards(255);
        while (fabs(yf - yi) > tolerance) {
          yi = Enes100.getY();
        }
      }
    }
    if (xf != xi) { // Checks if needed to move along x 
      if (xf > xi) { // Move right
        strafeLeft(255);
        while (fabs(xf - xi) > tolerance) {
          xi = Enes100.getX();
        }
      }
      else { // Move left
        strafeRight(255);
        while(fabs(xf - xi) > tolerance) {
          xi = Enes100.getX();
        }
      }
    }
  }
  else { // Robot facing left
    if (yf != yi) { // Checks if needed to move along y
      if (yf > yi) { // Move up
        strafeRight(255);
        while (fabs(yf - yi) > tolerance) {
          yi = Enes100.getY();
        }
      }
      else { // Move down
        strafeLeft(255);
        while (fabs(yf - yi) > tolerance) {
          yi = Enes100.getY();
        }
      }
    }
    if (xf != xi) { // Checks if needed to move along x 
      if (xf > xi) { // Move right
        driveBackwards(255);
        while (fabs(xf - xi) > tolerance) {
          xi = Enes100.getX();
        }
      }
      else { // Move left
        driveForwards(255);
        while(fabs(xf - xi) > tolerance) {
          xi = Enes100.getX();
        }
      }
    }
  }

  delay(100);  // Small delay to allow motors to react
  stopotv();
}

void mission() {
  float y = Enes100.getY();
  if (y > 1) {
    correctOrientation(PI / 2);
    moveHere(0.55, 0.20);
  } 
  else {
    correctOrientation(3 * PI / 2);
    moveHere(0.55, 1.80);
  }
}

void finish(float x) {
  moveHere(0.55, 1.87);
  moveHere(3.50, 1.87);
}

void motorCW (int m1, int m2, int p) {
  digitalWrite(m1, HIGH);
  digitalWrite(m2, LOW);
  analogWrite(S, p);
}

void motorCCW (int m1, int m2, int p) {
  digitalWrite(m1, LOW);
  digitalWrite(m2, HIGH);
  analogWrite(S, p);
}

void motorStop (int m1, int m2) {
  digitalWrite(m1, LOW);
  digitalWrite(m2, LOW);
  digitalWrite(S, LOW);
}

void driveForwards (int p) {
motorCCW(FRD1,FRD2, p);
motorCW(FLD1,FLD2, p);
motorCCW(BRD1,BRD2, p);
motorCW(BLD1,BLD2, p);
}
void driveBackwards (int p) {
motorCW(FRD1,FRD2, p);
motorCCW(FLD1,FLD2, p);
motorCW(BRD1,BRD2, p);
motorCCW(BLD1,BLD2, p);
}
void strafeLeft (int p) {
motorCCW(FRD1,FRD2, p);
motorCW(BRD1,BRD2, p);
motorCCW(FLD1,FLD2, p);
motorCW(BLD1,BLD2, p);
// check if it makes sense plss
}

void strafeRight (int p) {
motorCW(FRD1, FRD2, p);
motorCCW(BRD1, BRD2, p);
motorCW(FLD1, FLD2, p);
motorCCW(BLD1, BLD2, p);
}

void rotateOTV (int p) {
  if (p < 0) {
    p = abs(p);
    motorCW(FRD1, FRD2, p);
    motorCW(FLD1, FLD2, p);
    motorCW(BRD1, BRD2, p);
    motorCW(BLD1, BLD2, p);
  } else {
    p = abs(p);
    motorCCW(FRD1, FRD2, p);
    motorCCW(FLD1, FLD2, p);
    motorCCW(BRD1, BRD2, p);
    motorCCW(BLD1, BLD2, p);
  }

}


void stopotv () {
motorStop(FRD1, FRD2);
motorStop(FLD1, FLD2);
motorStop(BRD1, BRD2);
motorStop(BLD1, BLD2);
}

void setup() {
pinMode (FRD1, OUTPUT);
pinMode (FRD2, OUTPUT);
pinMode (BRD1, OUTPUT);
pinMode (BRD2, OUTPUT);
pinMode (FLD1, OUTPUT);
pinMode (FLD2, OUTPUT);
pinMode (BLD1, OUTPUT);
pinMode (BLD2, OUTPUT);
pinMode (S, OUTPUT);
Enes100.begin("Work in Progress", MATERIAL, 77, 1116, 3, 2);
  delay(200);
  Enes100.print("Successfully connected to the Vision System");
}

void loop() {
  bool v = Enes100.isVisible();
  if (v) {
    finish(x);
  }
  correctOrientation(PI/2);
}
  

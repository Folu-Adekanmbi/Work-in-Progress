#include <Enes100.h>

//F is front, B is back, R is right, L is left, D is drive, S is speed for these pin assignments
#define FRD1 8
#define FRD2 7
#define FLD1 10
#define FLD2 11
#define BRD1 6
#define BRD2 5
#define BLD1 12
#define BLD2 13
#define S 9

// Normalize angle to [-π, π]
float normalizeAngle(float angle) {
  angle = fmod(angle, 2*PI);
  if (angle > PI) angle -= 2 * PI;
  if (angle < -PI) angle += 2 * PI;
  return angle;
}

// Controls angular movement
int pd_angular_controller(float setpoint, float pv, float previous_error, long diffTime){
    float kp = 60;
    float kd = 17;
    float error = normalizeAngle(setpoint - pv);
    float derivative = 0;
    if (diffTime > 0) derivative = ((normalizeAngle(error - previous_error)) / (((float)diffTime) / 1000000));
    float control = kp * error + kd * derivative;
    control = constrain(control, -255, 255);
    if (control < 0) {
      if (fabs(control) <= 40) control = -40; 
    }
    if (control > 0) {
      if (fabs(control) <= 40) control = 40;
    }
    return (int)control;
}

// Controls forward/backward movement
int pd_drive_controller(float target_distance, float current_distance, float previous_error, long diffTime) {
    float kp = 1;
    float kd = 1;
    float error = target_distance - current_distance;
    float derivative = 0;
    if (diffTime > 0) derivative = (error - previous_error) / (((float)diffTime) / 1000000);
    float control = kp * error + kd * derivative;
    control = constrain(control, -255, 255);
    if (control < 0) {
      if (fabs(control) <= 40) control = -40; //Alter these values to be a value just below the minimum PWM for all motors to move the OTV
    }
    if (control > 0) {
      if (fabs(control) <= 40) control = 40; //Alter these values to be a value just below the minimum PWM for all motors to move the OTV
    }
    return (int)control;
}

// Controls strafe movement
int pd_strafe_controller(float target_distance, float current_distance, float previous_error, long diffTime) {
    float kp = 1;
    float kd = 1;
    float error = target_distance - current_distance;
    float derivative = 0;
    if (diffTime > 0) derivative = (error - previous_error) / (((float)diffTime) / 1000000);
    float control = kp * error + kd * derivative;
    control = constrain(control, -255, 255);
    if (control < 0) {
      if (fabs(control) <= 40) control = -40; //Alter these values to be a value just below the minimum PWM for all motors to move the OTV
    }
    if (control > 0) {
      if (fabs(control) <= 40) control = 40; //Alter these values to be a value just below the minimum PWM for all motors to move the OTV
    }
    return (int)control;
}

// Angle correction to a set angle
void correctOrientation(float tf) {
  tf = normalizeAngle(tf);
  float ti = Enes100.getTheta();
  float dt = normalizeAngle(tf - ti);
  long startTime = micros();
  long diffTime = 0;
  float P = 0;
  while (fabs(normalizeAngle(tf-ti)) > 0.02) {
    diffTime = micros() - startTime;
    ti = Enes100.getTheta();
    P = pd_angular_controller(tf, ti, dt, diffTime);
    dt = normalizeAngle(tf - ti);
    startTime = micros();
   // Enes100.println(dt);
    //Enes100.println(P);
    rotateOTV(P);
  }
  Enes100.println("I'm done rotating!!!!!! :DDDDDDDDDDDDDDD");
  stopotv();
}

/*
float quadrangle(float t) {
  t = fmod(t, PI*2);
  if (t < 0) t+= 2*PI;
  if (t >= PI / 4 && t < 3 * PI / 4) {    
    t = PI / 2;
  }
  else if (t >= 3 * PI / 4 && t < 5 * PI / 4) {                         
    t = PI;
  }
  else if (t >= t * PI / 4 && t < 7 * PI / 4) {               
    t = 3 * PI / 2;
  }
  else {
    t = 0;
  }
  return t
}
*/

void driveTo (float coordF, bool strafe, bool x){ 
  float coordi = 0;
  if (x) coordi = Enes100.getX();
  else coordi = Enes100.getY();
  float diffDist = coordF - coordi;
  long startTime = micros();
  long diffTime = 0;
  float P = 255;
  while (fabs(coordF - coordi) > 0.01) {
    diffTime = micros() - startTime;
    if (x) coordi = Enes100.getX();
    else coordi = Enes100.getY();
    if (strafe) P = pd_strafe_controller(coordF, coordi, diffDist, diffTime);
    else P = pd_drive_controller(coordF, coordi, diffDist, diffTime);
    diffDist = coordF - coordi;
    startTime = micros();
    if (strafe) strafeOTV(P);
    else driveOTV(P);
  }
  Enes100.println("I'm done driving!!!!!! :DDDDDDDDDDDDDDD");
  stopotv();
}

/*
// Moves to specific coordinates
void moveHere(float xf, float yf) {
  float xi = Enes100.getX();
  float yi = Enes100.getY();
  float ti = normalizeAngle(Enes100.getTheta());
  float dy = (yf - yi);
  float dx = (xf - xi);
  long startTime = micros();
  long diffTime = 0;
  float P = 255;

  qA = quadAngle(ti);
  correctOrientation();

  // Moves robot in right direction based on cardinal direction
  if (qA == 3 * PI / 2) { // Robot facing up
    if (dy != 0) { // Checks if needed to move along y 
      while (dy > tolerance) {
        diffTime = micros() - startTime;
        yi = Enes100.getY();
        P = pd_linear_controller(yf, yi, dy, diffTime);
        startTime = micros();
        dy = fabs(yf - yi);
        if (yf > yi) { // Move up
          driveForwards(P);
        }
        else { // Move down
          driveBackwards(P);
        }
      }
    }
    if (dx != 0) { // Checks if needed to move along x 
      while (dx > tolerance) {
        diffTime = micros() - startTime;
        xi = Enes100.getX();
        P = pd_linear_controller(xf, xi, dx, diffTime);
        startTime = micros();
        dx = fabs(xf - xi);
        if (xf > xi) { // Move right
          strafeRight(P);
        }
        else { // Move left
          strafeLeft(P);
        }
      }
    }
  }
  else if (qA == PI) { // Robot facing right
    if (yf != yi) { // Checks if needed to move along y
      if (yf > yi) { // Move up
        strafeLeft(255);
        while (fabs(yf - yi) > tolerance) {
          yi = Enes100.getY();
        }
      }
      else { // Move down
        strafeRight(255);
        while (fabs(yf - yi) > tolerance) {
          yi = Enes100.getY();
        }
      }
    }
    if (xf != xi) { // Checks if needed to move along x 
      if (xf > xi) { // Move right
        driveForwards(255);
        while (fabs(xf - xi) > tolerance) {
          xi = Enes100.getX();
        }
      }
      else { // Move left
        driveBackwards(255);
        while(fabs(xf - xi) > tolerance) {
          xi = Enes100.getX();
        }
      }
    }
  }
  else if (qA == PI / 2) { // Robot facing down
    if (yf != yi) { // Checks if needed to move along y
      if (yf > yi) { // Move up
        driveBackwards(255);
        while (fabs(yf - yi) > tolerance) {
          yi = Enes100.getY();
        }
      }
      else { // Move down
        driveForwards(255);
        while (fabs(yf - yi) > tolerance) {
          yi = Enes100.getY();
        }
      }
    }
    if (xf != xi) { // Checks if needed to move along x 
      if (xf > xi) { // Move right
        strafeLeft(255);
        while (fabs(xf - xi) > tolerance) {
          xi = Enes100.getX();
        }
      }
      else { // Move left
        strafeRight(255);
        while(fabs(xf - xi) > tolerance) {
          xi = Enes100.getX();
        }
      }
    }
  }
  else { // Robot facing left
    if (yf != yi) { // Checks if needed to move along y
      if (yf > yi) { // Move up
        strafeRight(255);
        while (fabs(yf - yi) > tolerance) {
          yi = Enes100.getY();
        }
      }
      else { // Move down
        strafeLeft(255);
        while (fabs(yf - yi) > tolerance) {
          yi = Enes100.getY();
        }
      }
    }
    if (xf != xi) { // Checks if needed to move along x 
      if (xf > xi) { // Move right
        driveBackwards(255);
        while (fabs(xf - xi) > tolerance) {
          xi = Enes100.getX();
        }
      }
      else { // Move left
        driveForwards(255);
        while(fabs(xf - xi) > tolerance) {
          xi = Enes100.getX();
        }
      }
    }
  }

  delay(100);  // Small delay to allow motors to react
  stopotv();
}


void mission() {
  float y = Enes100.getY();
  if (y > 1) {
    correctOrientation(PI / 2);
    moveHere(0.55, 0.20);
  } 
  else {
    correctOrientation(3 * PI / 2);
    moveHere(0.55, 1.80);
  }
}

void finish(float x) {
  moveHere(0.55, 1.87);
  moveHere(3.50, 1.87);
}
*/


void motorCW (int m1, int m2, int p) {
  digitalWrite(m1, HIGH);
  digitalWrite(m2, LOW);
  analogWrite(S, p);
}

void motorCCW (int m1, int m2, int p) {
  digitalWrite(m1, LOW);
  digitalWrite(m2, HIGH);
  analogWrite(S, p);
}

void motorStop (int m1, int m2) {
  digitalWrite(m1, LOW);
  digitalWrite(m2, LOW);
  digitalWrite(S, LOW);
}

void driveOTV (int p) {
  if (p < 0){
    p = abs(p);
    motorCW(FRD1,FRD2, p);
    motorCCW(FLD1,FLD2, p);
    motorCW(BRD1,BRD2, p);
    motorCCW(BLD1,BLD2, p);
  }
  else {
    p = abs(p);
    motorCCW(FRD1,FRD2, p);
    motorCW(FLD1,FLD2, p);
    motorCCW(BRD1,BRD2, p);
    motorCW(BLD1,BLD2, p);
  }
}

void strafeOTV (int p) {
  if (p < 0) {
    p = abs(p);
    motorCCW(FRD1,FRD2, p);
    motorCW(BRD1,BRD2, p);
    motorCCW(FLD1,FLD2, p);
    motorCW(BLD1,BLD2, p);
  }
  else {
    p = abs(p);
    motorCW(FRD1, FRD2, p);
    motorCCW(BRD1, BRD2, p);
    motorCW(FLD1, FLD2, p);
    motorCCW(BLD1, BLD2, p);
  }
// check if it makes sense plss
}

void rotateOTV (int p) {
  if (p < 0) {
    p = abs(p);
    motorCW(FRD1, FRD2, p);
    motorCW(FLD1, FLD2, p);
    motorCW(BRD1, BRD2, p);
    motorCW(BLD1, BLD2, p);
  } else {
    p = abs(p);
    motorCCW(FRD1, FRD2, p);
    motorCCW(FLD1, FLD2, p);
    motorCCW(BRD1, BRD2, p);
    motorCCW(BLD1, BLD2, p);
  }

}

void stopotv () {
  motorStop(FRD1, FRD2);
  motorStop(FLD1, FLD2);
  motorStop(BRD1, BRD2);
  motorStop(BLD1, BLD2);
}

void setup() {
pinMode (FRD1, OUTPUT);
pinMode (FRD2, OUTPUT);
pinMode (BRD1, OUTPUT);
pinMode (BRD2, OUTPUT);
pinMode (FLD1, OUTPUT);
pinMode (FLD2, OUTPUT);
pinMode (BLD1, OUTPUT);
pinMode (BLD2, OUTPUT);
pinMode (S, OUTPUT);
Enes100.begin("Work in Progress", MATERIAL, 495, 1116, 3, 2);
  delay(200);
  Enes100.print("Successfully connected to the Vision System");
}

void loop() {
  correctOrientation(PI/2);
  delay(100000000000000000000);
}
  
